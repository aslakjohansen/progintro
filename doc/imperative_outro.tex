\chapter{Outro}

% what we have covered (turing completeness)
This is the end of the first part of the book. By now you should have a good grasp of imperative programming in \csharp. We have covered the primitive types, the basic data structures, the difference between value and reference types, branching, loops, functions and exceptions. With this, you can implement \textsl{any} computer \idx{algorithm}{Algorithm}. That's a big thing!

% what we are missing (standard library)
That still doesn't allow us to do a whole lot though. We need more ways of interfacing with the computer, and to make even remotely decent use of \csharp\ we also need booth the object-oriented features and the \idx{standard library}{Standard library}.

% looking ahead (a perhaps more attractive way of programming)
In the next part of this book, we will look into object-oriented programming. It provides developers with a structured way of modeling high-level concepts. Working at a higher level of abstraction is convenient and typically makes developers to work more \idx{efficiently}{Efficiency!Developer}. It should be seen as an addition to what we have covered in part \ref{part:ip}; as an extension to your toolbox. \csharp\ was designed for object-oriented programming, and \idx{tradeoffs}{Tradeoff} were made in favor of this programming style. If you choose not use its object-oriented features you are doing yourself a great disservice, and should probably go for a different language.

\section{Exercises}

Before looking into the following exercises, please note that there is a lot less hand-holding in the phrasing of these exercises, and they are an order of magnitude more \idx{complex}{Complexity} than the previous exercises in this book. At this point, you do have the tools to solve them though. See them as a challenge, and don't worry too much if you end up giving up.

\subsection{Sūdoku}

Write a program that solves a puzzle.

This is -- so far -- the final exercise in our \idx{Sūdoku}{Sūdoku} series. This series consists of:
\begin{itemize}
  \item A puzzle representation in exercise \ref{q:primdata:sudoku-puzzle}.
  \item A \idx{pretty-printer}{Pretty printing} in exercise \ref{q:functions:sudoku-print}.
  \item A checker in exercise \ref{q:primdata:sudoku-check}.
\end{itemize}

\subsection{Game of Life}

Make an implementation of \idx{John Comway}{Conway!John}'s \idx{Game of Life}{Game of Life}. You can find a description of this simulation on \idx{Wikipedia}{Wikipedia}.

\textbf{Note:} A few hints:
\begin{itemize}
  \item Illustrate each generation using characters (e.g., a space for no life and an asterisk for life).
  \item Pick a world size that fits on your screen.
  \item Insert a pause in between each generation.
  \item Initialize your world randomly
\end{itemize}

We have not quite covered everything needed to do follow these hints. The missing pieces, you can derive experimentally from this code:

\begin{minted}{csharp}
Random r = new Random();

while (true) {
  Console.WriteLine(r.Next(2));
  Thread.Sleep(1000);
}
\end{minted}

\subsection{Eight Queens Puzzle}

Solve the \idx{eight queens puzzle}{Queens puzzle!Eight} through code. To solve the problem, you need to place eight chess queens on a eight-by-eight chessboard in such a way that no two queens threaten each other. That is, each row, column and diagonal can have at most one queen. Write a program that finds one (or alternatively, \textsl{all}) solutions to this problem.

\textbf{Hint:} Try to iterate through all configurations of possible queen positions and check which of these are valid solutions.

\textbf{Bonus:} The eight queens puzzle can be generalized to an \idx{$n$ queens puzzle}{Queens puzzle!N}. In this puzzle, you need to place $n$ queens on an $n \times n$ chessboard. By solving this generalization, your solution will be capable of solving any specific variant (e.g, $n=8$).

