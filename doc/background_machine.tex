\section{The Machine}
\label{sec:machine}

\subsection{History}

% Antikythera mechanism https://en.wikipedia.org/wiki/Antikythera_mechanism

% Jacquard machine https://en.wikipedia.org/wiki/Jacquard_machine

% Difference Engine https://en.wikipedia.org/wiki/Difference_engine

% Mutual Exclusion https://en.wikipedia.org/wiki/Mutual_exclusion

% C https://en.wikipedia.org/wiki/C_(programming_language)

% Taming of the Alpaca

\subsection{Overview}

% description of computer: model description as data flow (input, memory, processor, load instruction, registers, operator instructions, ALU, store instruction, memory, output)
Figure \ref{fig:machine:computer}

\begin{figure}[tbp]
  \input{figs/machine_computer.tex}
  \caption{Model of computer.}
  \label{fig:machine:computer}
\end{figure}

\subsection{Memory Model}

\begin{figure}[tbp]
  \input{figs/machine_memory.tex}
  \caption{Memory model.}
  \label{fig:machine:memory}
\end{figure}

\subsection{Registers}

\subsection{Instructions}

\subsubsection{Memory Access}

\subsubsection{Arithmetic Operations}

\subsubsection{Choice}

\subsection{Big Picture}

% intro
The components that of the machine that we have covered can be put together around the central processing unit (i.e., the \idx{CPU}{CPU}). An implementation of a primitive RISC-V processor is illustrated in figure \ref{fig:machine:riscv}. In reality, it is much more complicated, and RISC-V is a simple \idx{processor architecture}{Architecture!Processor}. Lets briefly go through what is going on in this figure.

\begin{figure}[tbp]
  \input{figs/machine_riscv.tex}
  \caption{Primitive model of a RISC-V Processor.}
  \label{fig:machine:riscv}
\end{figure}

% signals: bloacks and arrows, complex blocks, what complex mean, signals (1 or more bits), control and data
The diagram consists of various blocks connected by arrows. These blocks are \idx{complex}{Complex!Block}. That is, they represent a \idx{logical}{Logical} unit but are physically constructed from smaller parts \ldots\ with arrows between them. We call the arrows \idx{signals}{Signal}. They represent a value of one or more bits. One can think of them as how data flows through the processor. Concretely, this is accomplished through \idx{register transfer level}{Register Transfer Level} (RTL) logic and a \idx{clock signal}{Signal!Clock}. But then things get really complecated, and we don't need it that badly.

% data and control plane:
Some of these signals exists to move data around between memory, registers and the implementation of the instructions. These are called \idx{data signals}{Signal!Data}, and we say that these make up the \defi{data plane}{Plane!Data}. This is a cross-cut of the processor through which \say{data flows}. Other signals are \idx{control signals}{Signal!Control}, and they make up the \defi{control plane}{Plane!Control}. That is a different cross-cut that informs the blocks of \textsl{how} they should operate. For instance, the block that executes the instructions is called an ALU. It has a number of generic inputs and a control signal tells it which operation (e.g., an addition or a division) it is supposed to perform on these. % TODO: should this paragraph be moved down to after the alu?

% multiplexers (mux): identifying the component visually, interface (number of inputs, one output, a control), role of control

% and: identifying the component visually, interface (number of inputs, one output), what the output represent

% alu:  identifying the component visually, much more complicated block, interface (two data inputs, one control input, one data output, one control output, one control output), perform the operation specified by the control input on the data inputs and output the resulting value on the data output, boolean signal for whether a branch should be taken, two variactions (the generic one covered here, a specialized version that can only addand has no control interface)

\subsubsection{Data Plane}

% pc: a register

% instruction fetch and decode

% register read

% alu operation

% memory operation

% branching

\subsubsection{Control Plane}

% the clock cycle ticks

% ALU signals

% Branch

% MemRead & MemWrite

% RegWrite & MemtoReg

\subsection{Followup}

% why languages tend to look the same
You will find that many of the design choices of \csharp, and any other programming language for that matter, have their roots in this machine. There is a reason why these languages look like the do. At the end of the day, they have to be executed on a physical processor, and often there is really only one way of doing something on such a processor that doesn't incur a huge performance penalty.

