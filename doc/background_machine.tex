\section{The Machine}
\label{sec:machine}

\subsection{History}

% Antikythera mechanism https://en.wikipedia.org/wiki/Antikythera_mechanism

% Jacquard machine https://en.wikipedia.org/wiki/Jacquard_machine

% Difference Engine https://en.wikipedia.org/wiki/Difference_engine

% Mutual Exclusion https://en.wikipedia.org/wiki/Mutual_exclusion

% C https://en.wikipedia.org/wiki/C_(programming_language)

% Taming of the Alpaca

\subsection{Overview}

% description of computer: model description as data flow (input, memory, processor, load instruction, registers, operator instructions, ALU, store instruction, memory, output)
Figure \ref{fig:machine:computer} shows the model of a computer that we will rely on. Input (e.g, from keyboard) ends up in the computers \idx{main memory}{Memory!Main}. The processor, as the name implies, \textsl{processes} \idx{instructions}{Instruction}. Each \idx{processor architecture}{Architecture!Processor} or type supports some instruction repertoire. In that repertoire you will find instructions for load values from main memory into registers. \idx{Registers}{Register} are named values that the processor can instructions can access directly. Other instructions performs operations on registers (e.g., for adding two values). Such instructions are processed by something called an arithmetic logic unit (or \idx{ALU}{ALU} in daily speech). Yet other instructions can store the value of a register to main memory. We also say that we \say{write to memory}. Storing values to certain portions of memory yields an output. For instance, some computers have a \idx{frame buffer}{Frame buffer} in main memory that defines what ends up on your screen. Writing to that part of the memory will affect what you see on your screen.

\begin{figure}[tbp]
  \input{figs/machine_computer.tex}
  \caption{Model of computer.}
  \label{fig:machine:computer}
\end{figure}

% focus on RISC-V
There are many different \idx{processor architectures}{Architecture!Processor}. Popular ones include \idx{AMD64}{AMD64}, \idx{ARM}{ARM} and \idx{RISC-V}{RISC-V}. In this book, we will look into the integer side of the 32-bit RISC-V architecture (aka the \idx{RV32I}{RV32I} instruction set). This is a simple instruction set and architecture, and the model of this is transferable to the other processor architectures for the purposes of this book.

\subsection{Memory Model}

% addresses
The memory of a computer is laid out in a sequence of bytes. The first byte has address zero, the second one has address one, and so on. Most values take up more than a single byte. If a value takes up address four through seven then we refer to its position through its lowest address (i.e., four).

% figure overview
The memory is laid out as illustrated in figure \ref{fig:machine:memory}. At the lowest \idx{memory segment}{Memory!Segment} we have reserved data. Among these, we have memory-mapped input and output. Every time we write to an output, it triggers some electrical signal to be generated to a peripheral to the processor. Every time we read from an input, a value is \textsl{read} from some peripheral to the processor. Then we have a text segment that contains our program code. This is the instructions that tells the processor what to do. The next segment contains static data that is available to the processor, and the remaining memory is used for dynamic program data. This is the \textsl{working area} of the processor.

\begin{figure}[tbp]
  \input{figs/machine_memory.tex}
  \caption{Memory model.}
  \label{fig:machine:memory}
\end{figure}

% heap
As our program executes, it produces temporary data. This needs to be stored somewhere. In practice, it is stored on a \idx{heap}{Heap} that is placed at the lower addresses of the dynamic program data segment. Throughout the lifecycle of the program, this \idx{datastructure}{Datastructure} will grow to higher addresses when more space is needed, and shrink when the highest addresses are no longer needed. It is up to the program to to administer this. In \csharp, however, a so-called \idx{garbage collector}{Garbage collector} will do this for you.

% stack
Another data structure grows from the other end of the dynamic program segment in the other direction. This way, we won't run out of memory until all the memory is in use. This datastructure is called a stack, and because it is so central to the operation of the computer it is referred to as \idx{\textsl{the} stack}{Stack, The}. The stack is used to store data when groups of instructions \textsl{farm out} part of their function to other groups of instructions. More about this in the next section.

\subsection{Registers}

% how many, naming (x0 through x31) special roles? ABI names

% figure: caller saved, callee saved
\begin{figure}[tbp]
  \input{figs/machine_registers.tex}
  \caption{Register overview.}
  \label{fig:machine:regs}
\end{figure}

%TODO: we need an introduction to branches and loops in order to talk caller/callee saved registers. Where should it be placed? Maybe add a forward reference to the section covering the JAL instruction?

\subsection{Instructions}

% intro
The instruction repertoire of the majority of instruction sets is fairly large, but few of them adds to the understanding of the fundamental operation of the processor. To keep things somewhat simple, we stick to covering a fairly minimal subset of the instructions.

%TODO: where to introduce instruction sets

\subsubsection{Memory Access}

% access model: most program data is in main memory, we can only operate on registers and we have a limited number of these, (we need a way of loading data from main memory into registers so that we can work on it, and then store the results back into main memory to make space -- in the registers -- for more useful work)
The processor can only operate on registers, but has a very limited number of them. For 32 bit RISC-V, there are 32 of them. That is only enough for the smallest of programs, and nothing that can be written in \csharp. Instead, most program data resides in main memory. This means that we need a way of loading data from main memory into registers so that we can work on it, and then another way of storing the results back into main memory to make (register) space for other data. This way, we can continue to do useful work.

% enumerate: load and store instructions
We have a number of instructions for loading and storing data. In this description, we only care about those that operates on \textsl{words}. A \defi{word}{Word} is the type of integer that matches the size that the processor is optimized to work on. In our case, it is a 32 bit integer.
\begin{itemize}
  \item \instname{LW} (\say{load word}) This loads a word from an address in main memory into a named register in the processor.
  \item \instname{SW} (\say{store word}) Stores the value of a named register in the processor to an address in main memory.
\end{itemize}
These addresses are the sum of the value of a register, and a 12-bit integer that is encoded in (read: part of) the instruction itself. That last part acts as a static offset to the value in the register.

\subsubsection{Arithmetic Operations}

% intro: what is?, operation interface (1-2 inputs, 1 output), examples (+-*/, but there are more that fits the pattern)
The processor implements instructions for a number of arithmetic operations. The classical ones are addition, subtraction, multiplication and division. These make up a class of instructions that take two input values and produce a single output value. There are other operations that fit that pattern and have value for programmers. Boolean operations that you will get familiar with in section \ref{primitives:bools} are examples of these. The processor supports a number of these through instruction.

% register and immediate variants: summary (2 inputs, 1 outputs), generic version (register, restricts 3 registers), registers as a scarce resource, common case of having one fixed operand, specialized version (restricts only 2 registers), this means that the compiler (that turns the human readable source code into instructions) can do a better job.
There is a generic variant of these instructions that maps each input and output to a register. That is, it takes inputs from two registers, and writes the output to a single register. These three registers could potentially be the same. Often these operations have a fixed operand though. As registers are a scarce resource, specialized variants -- that have the fixed value encoded directly in the instruction -- are available for some of the operations. Such fixed values are then called \idx{immediate}{Value!Immediate} values. Because of their lower register footprint, the compiler (that turns the human readable source code into instructions) can do a better job.

% selection of instructions: add, addi, mul, !muli
As these instructions look very similar, we will only cover a few:
\begin{itemize}
  \item \instname{ADD} (\say{add}) Add the values of two registers and store the resulting value in a third register.
  \item \instname{ADDI} (\say{add immediate}) Add an immediate value to the value of a register and store the resulting value in a second register.
  \item \instname{MUL} (\say{multiply}) Multiply the values of two registers and store the resulting value in a third register. No immediate variant exist for this operation.
\end{itemize}

% floats: in this book we only cover integers, similar instructions exist for floats
In this book we will only cover integers to this depth. Similar instructions exists for floating point numbers that you may know as decimal numbers. The binary representation of the numbers is much more complicated, and this brings some intricacies. These are detailed in section \ref{primitives:float} when we cover floating point numbers in \csharp.

\subsubsection{Choice}

% source: https://docs.openhwgroup.org/projects/cva6-user-manual/01_cva6_user/RISCV_Instructions_RV32I.html#control-transfer-instructions

Instructions are by default \idx{evaluated}{Evaluation!Instructions} in the order they are laid out in memory. Special \textsl{branch} instructions can be used to deviate from this rule. Some are unconditional. That is, they \textsl{jump} to a specific memory address when evaluated. Others are conditional. That means that they only jump if a certain condition is met.

Unconditional branch instructions:
\begin{itemize}
  \item \instname{J} (\say{jump}) Jump to a specific memory address.
  \item \instname{JAL} (\say{jump and link}) Jump to a specific memory address, and \textsl{link}.
\end{itemize}

But, what does it mean to \defi{link}{Link!Instruction level}? Instructions are often arranged in groups. These are the equivalent of what you will come to know as \idx{functions}{Function}. They operate on some registers and can use the \instname{JAL} instruction to transfer execution to another group of instructions. That group of instructions can then solve a part of the problem, place the result in a specific register (or at a specific memory address), and then transfer execution back to the first group of instructions. We say that the first group \idx{calls}{Call} the second. This makes the first group take the role of the \idx{caller}{Caller} and the second group that of the \idx{callee}{Callee}. To make sure that there is no conflict in register use (e.g., that the callee overrides a register that is in use by the caller) a convention is established for which role needs to save the contents of a register before overriding it (and restore it before \idx{returning}{Return} execution). This can be seen in figure \ref{fig:machine:regs}.

Conditional branch instructions (no link):
\begin{itemize}
  \item \instname{BNE} (\say{branch not equal}) Jump to a specific memory address if two register have different values. Otherwise continue.
  \item \instname{BLT} (\say{branch lest than}) Jump to a specific memory address if one register has a value that is less than that of another one. Otherwise continue.
\end{itemize}

\subsubsection{Instruction Format Types}


\subsection{Big Picture}

% intro
The components that of the machine that we have covered can be put together around the central processing unit (i.e., the \idx{CPU}{CPU}). An implementation of a primitive RISC-V processor is illustrated in figure \ref{fig:machine:riscv}. In reality, it is much more complicated, and RISC-V is a simple \idx{processor architecture}{Architecture!Processor}. Lets briefly go through what is going on in this figure.

\begin{figure}[tbp]
  \input{figs/machine_riscv.tex}
  \caption{Primitive model of a RISC-V Processor.}
  \label{fig:machine:riscv}
\end{figure}

% signals: bloacks and arrows, complex blocks, what complex mean, signals (1 or more bits), control and data
The diagram consists of various blocks connected by arrows. These blocks are \idx{complex}{Complex!Block}. That is, they represent a \idx{logical}{Logical} unit but are physically constructed from smaller parts \ldots\ with arrows between them. We call the arrows \idx{signals}{Signal}. They represent a value of one or more bits. One can think of them as how data flows through the processor. Concretely, this is accomplished through \idx{register transfer level}{Register Transfer Level} (RTL) logic and a \idx{clock signal}{Signal!Clock}. But then things get really complicated, and we don't need it that badly.

% data and control plane:
Some of these signals exists to move data around between memory, registers and the implementation of the instructions. These are called \idx{data signals}{Signal!Data}, and we say that these make up the \defi{data plane}{Plane!Data}. This is a cross-cut of the processor through which \say{data flows}. Other signals are \idx{control signals}{Signal!Control}, and they make up the \defi{control plane}{Plane!Control}. That is a different cross-cut that informs the blocks of \textsl{how} they should operate. For instance, the block that executes the instructions is called an ALU. It has a number of generic inputs and a control signal tells it which operation (e.g., an addition or a division) it is supposed to perform on these.

% alu: identifying the component visually, much more complicated block, interface (two data inputs, one control input, one data output, one control output, one control output), perform the operation specified by the control input on the data inputs and output the resulting value on the data output, boolean signal for whether a branch should be taken, two variations (the generic one covered here, a specialized version that can only add and has no control interface)
There are three \idx{ALUs}{ALU} on the diagram. They look a bit like an arrow pointing to the right and are labeled either \say{ALU} or \say{+}. The latter version is a specialized version of the former. The specialized version takes two data inputs and produces a data output. This output is the result of adding the two inputs. The generic version has a control input which tells it which operation to perform. This ALU supports a large number of operations, and will perform the operation specified by the control input on the data inputs and output the resulting value on the data output. For \idx{arithmetic operations}{Operation!Arithmetic}, this is straight forward to imagine: If the control signal specifies a multiplication operation and the data inputs a two and three, then the data output becomes six. Other operations are used to transfer the control flow from one place in \idx{instruction memory}{Memory!Instruction} to another. This can be either conditional (e.g., using the \idx{BNE}{BNE@\texttt{J} instruction} or \idx{BLT}{BLT@\texttt{BLT} instruction} instruction) or unconditional (e.g., using the \idx{J}{J@\texttt{J} instruction} or \idx{JAL}{JAL@\texttt{JAL} instruction} instruction). If a branch operation needs to be executed, the ALU will indicate this using its control output signal.

% and: identifying the component visually, interface (number of inputs, one output), what the output represent
If we follow that control signal from the ALU, we will find a shape labeled \say{AND} that on the input side looks like a rectangle and on the output side it looks like a circle. It is an \idx{AND gate}{Gate!AND}. That is a piece of \idx{digital electronics}{Electronics!Digital} that produces a signal that represents whether all of the inputs are true.

% multiplexers (mux): identifying the component visually, interface (number of inputs, one output, a control), role of control
In the diagram, you will find three \idx{multiplexers}{Multiplexer} (or \idx{mux}{Mux} for short). These are labeled \say{mux}. They each have one outgoing edge, two incoming black edges, and one incoming \textsl{colored} edge. The mux is a selective forwarding mechanism, based on the value of the colored input, it forwards the value on one of the black inputs to its output. For this reason, the colored input is called a \idx{control signal}{Signal!Control}.

\subsubsection{Data Plane}

% pc: a register (something that can hold a value), usually increments in steps of 4, why that is
The execution of an instruction starts at the \idx{program counter}{Program counter} (or PC, for short). It is usually incremented in steps of four as this matches the size of a RISC-V 32-bit instruction. The program counter is a \idx{register}{Register} that holds the address of the next instruction. This address is fed into the program memory block.

% instruction fetch and decode: the next step is to fetch that instruction (at that address) from instruction memory and decode it into its principal components, this usually includes instruction identity and a number of registers or immediate values
The program memory block then \idx{fetches}{Fetching} the instruction that the program counter \idx{points to}{Pointer}. It then decodes it into it principal components. These are the code for the operation (aka the instruction \idx{identity}{Identity}), and the relevant register numbers and/or immediate values.

% register read: reading the values of each of these registers, register bank
Depending on the concrete instruction, up to two of those registers are used as input to the operation. So the next step is to read the values of these registers from the \idx{register bank}{Register bank}. These values are produced at the labels \say{Value 1} and \say{Value 2} in the diagram. If only one of them is needed, then the other will be \idx{undefined}{Undefined}. That means that the \idx{architectural model}{Architectural mode!Processor} of the processor does not dictate what any physical processor should do in this case. While this may seem like a problem, the control signals (that we will cover in section \ref{sec:bg:machine:control_plane}) will make sure it does cause any trouble.

% alu operation: operands to alu, register vs immediate value, control module tells it which operation to perform, many instructions will require the result of the operation to be written back to the register bank
Data flows through the \textsl{main} ALU. The first input comes from a register, but the second comes -- depending on instruction -- from either a register or an immediate value encoded directly in the instruction. The control model tells it which operation to perform. Many instructions will require the result of the operation to be written back to the register bank, in which case the control module will make sure this happens.

% memory operation: other operations will need to store the value of some register to memory, how does this value get from the register to the data input of data memory?
Other instructions will need to \idx{store}{Store} the value of some register in memory, or \idx{load}{Load} a value from memory into a register. The data memory is responsible for those load and stope operations. The data involved in a store instruction will essentially bypass the main ALU by feeding \say{Value 2} for the register bank into \say{Data} of the data memory. The address is calculated by the ALU though.

% register write back
In a load operation, the \say{Value} output of the data memory block (which represents the data at the input \say{Address}) is fed into the \say{Data} input of the register bank. A mux on the way will have to be instructed by the control block to route the data signal appropriately.

% branching: when is it decided to branch? This can be seen through the AND gate that controls whether the +4 PC increment should be overwritten by something else, but where should it branch to? by tracing back the lines we can see that we add something to the current PC value (e.g., an offset), this offset is hardcoded in the instruction, we say that the branch takes a relative jump
% TODO: we are covering the control plane here. Should that part be moved into the next section, or does that separation not make sense?

\subsubsection{Control Plane}
\label{sec:bg:machine:control_plane}

% the clock cycle ticks: the cpu contains a clock, this is essentially a metronome for the machine, every time it ticks a new instruction is processed, footnote (while this is true in our simplified setup, it becomes a lot more complicated in real processors), this is the original control signal
The processor contains a \idx{clock generator}{Clock!Generator}. This is essentially a \idx{metronome}{Metronome} for the machine. Every time it ticks, a new instruction is processed\footnote{While this is true in our simplified setup, real processors are much more complicated. This is, in part, how they achieve a high \idx{execution speed}{Execution!Speed}.}. The clock signal is the original control signal.

% ALU signals: ALUOp for choosing operation, output for making jumps, when do we need to make jumps? (unconditional and conditional)
At each \idx{clock cycle}{Clock!Cycle}, the ALU receives two data inputs. An \say{ALUOp} control signal informs it of which operation to perform on these inputs. For branch instructions, the ALU has a control output that dictates whether the a jump should be initiated. For a \idx{unconditional jump}{Jump!Unconditional} instruction that control output will always indicate to initiate the jump. For a \idx{conditional jump}{Jump!Conditional} (i.e., a branch) it will depend on the \idx{condition}{Condition} of the jump.

% Branch: normal operation (PC+=4), deviation from norm (a branch: the AND'ing of alu output control signal and Branch signal from control block), if the control block is telling us that we have a branch operation (Branch signal) and the alu tells us that the branch should be taken then we branch
Lets find the \idx{program counter}{Program Counter} again. This is the \idx{register}{Register} that holds the \idx{address}{Address} of the current instruction. The execution of a non-branch operations is followed by the execution of the instruction stored at the following address in memory. Since all instructions are 4 bytes long (i.e., they take up 4 bytes of space), this next instruction resides at a memory address that is 4 higher. This, you can see implemented using a \say{+} ALU in the beginning of the diagram. However, a mux placed in this \idx{data path}{Path!Data}so that this \textsl{normal} operation can be bypassed in case of a jump. In those cases, it is not 4 that is added to the address, but an \idx{immediate value}{Value!Immediate} that is \idx{encoded}{Encoding} in the instruction. This can be seen in the other \say{+} ALU. Whether to jump is determined by a control signal that comes from the AND gate, and that states that we jump if and only if the control blocks \say{Branch} signal and the ALUs output signal agrees that a branch should be taken.

% MemRead & MemWrite: from the data memorys perspective there are three kinds of instructions (those that have no relevance, those that read and those that write), in the no relevance case we don't want to stress the memory, in the read case we want to produce an output data signal, this is indicated by the MemRead control signal, in the write case we want to modify the contents of data memory (under no other circumstances is this acceptable), this is indicated by the MemWrite control signal
From the perspective of the \idx{data memory}{Memory!Data}, there are three kinds of instructions, namely (i) those that have no relevance it it, (ii) those that read data, and (iii) those that write data. In the first case, there is no need to stress the memory and nothing should be done. In the second case, an output data signal should be produced that contains the read value. This is indicated by the \say{MemRead} control signal. In the third case, the contents of the data memory should be updated according to the blocks data inputs. Under no other circumstances is it acceptable to write to this memory. This is indicated by the \say{MemWrite} control signal.

% RegWrite & MemtoReg: two classes of operations (whether a write to a register is part of the operation), how RegWrite fits in, two classes of operations when a write is part of the operation (depending on the source of the write), do we write the output from the ALU (e.g., as in a plus operation) or do we write data that are loaded from data memory (e.g., as in a load operation).
Similarly to the data memory, the \idx{register bank}{Register!Bank} can be read from and written to. What to do depends on the instruction, and it is the job of the control block to decode the instruction and \ldots\ well \ldots\ \textsl{control} the register bank. The register addressed on the data inputs \say{Register 1} and \say{Register 2} are always read and outputted to \say{Value 1} and \say{Value 2}. The \say{RegWrite} control signal controls whether the \say{Data} input should be written to the register addressed by \say{Register 3}. The \say{MemtoReg} control signal determines which data output is fed into the \say{Data} input of the register bank: Should it be the output of the ALU (e.g., as in a plus instruction) or should it be the output of data memory (e.g., as in a load instruction)?

\subsection{\csharp\ Link}

% the operating system / vm
This machine model is slightly deceptive in the sense that we -- in this book -- won't be programming the processor itself. A special program called a \idx{kernel}{Kernel} is running on top of the processor. This program \idx{orchestrates}{Orchestration} a number of programs that make up the \idx{operating system}{Operating system}. When we \idx{execute}{Execution} the \csharp\ programs that we make throughout this book, we do so through a special program called a \idx{virtual machine}{Virtual machine} that runs on this operating system. All of these programs, except for the kernel, exists in the dynamic program data memory segment. The virtual machine translates the \idx{CIL}{CIL} instruction of your compiled \csharp\ code into instructions that can be executed on your physical processor.

\subsection{Takeaways}

% why languages tend to look the same
You will find that many of the design choices of \csharp, and any other programming language for that matter, have their roots in this machine. There is a reason why these languages look like the do. At the end of the day, they have to be executed on a physical processor, and often there is really only one way of doing something on such a processor that doesn't incur a huge performance penalty.

% come back to this section
You likely have found this section difficult to follow. That's okay. As you progress though this book, do yourself the favor of returning to this section. It should be easier to read by then.

