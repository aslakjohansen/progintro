\chapter{Parameterized Types}

% intro: inheritance as a way to avoid duplicate code, it works by extending some basic definition, but what if the basic definition is the part that we want variations of? 
In chapter \ref{sec:inheritance}, we covered the concept of \idx{inheritance}{Inheritance}. We presented it as a way of avoiding \idx{duplicate code}{Duplicate code} while allowing for \idx{polymorphic}{Polymorphism} access to variants of behavior implementation. It worked by extending some basic definition in order to specialize the type definition. So, a shared starting point with individual extensions. But what if the basic definition is the part that we want variations over? Then we use \idx{parameterized types}{Type!Parameterized} (aka \idx{generics}{Generics}).

\section{Problem}

% what is a pair?
A minimal example of this is a \say{pair}. That is, two of something. The concept could relate to integers, socks, dice or something different altogether. In object-oriented programming, it seems natural to use a class to wrap two elements of the relevant type. Figure \ref{fig:generics:pair:problem} illustrates how such a pair class could be defined for integers and for points.

% fig: code presentation
\begin{figure}[tbp]
  \input{figs/generics_pair_problem.tex}
  \caption{Two similar classes with varying base definition.}
  \label{fig:generics:pair:problem}
\end{figure}

% differences
It doesn't quite feel right though. The concept of the pair is intertwined with the type of the elements. The \methodname{ToString} method and the body of the constructor are exactly the same in the two classes. If we look past the types, then so are the instance variables and constructor parameters. These are all things that are linked to the concept of a pair; not the type of the elements. The only reason for the classes (and thus their constructors) to be named differently is that they can't have the same name.

% problems: scalability
The consequences of this extend beyond mere practicalities. For starters it does not \idx{scale}{Scalability} with respect to element types: We need one definition of a pair for each element type we want to support. So, if I want to have 17 different elements types in pairs, I need 17 different pair classes. That is a lot of code that I have to manually keep up to date as my perception of a pair evolves. This evolution is a reference to how the code changes over time as features are added or bugs corrected. We say that this results in low \idx{maintainability}{Maintainability}.

% problem: no common type
But this still leaves us with a missed opportunity for polymorphism. It would be nice to be able to be able to define code that can can handle any pair. We could accomplish this by placing be pair behavior functionality in an interface that all pair types implement. Then that interface would represent the type that all pairs \idx{satisfy}{Type!Satisfiability}. But we would still have the scalability problem.

% Object
We could define the class as a \typename{Object} pair. That would allow any type to satisfy the instance variables. But we would this would come with two negative consequences, namely:
\begin{enumerate}
  \descitem{Loss of \idx{type specificity}{Type!Specificity}:} We would bypass the \idx{compilers}{Compiler} mechanisms for ensuring \idx{type safety}{Type!Safety} and shift that uncertainty to the \idx{runtime}{Runtime!The}. Without the guarantees of the compiler, we would need to \idx{downcast}{Downcast} our instance variables in order to access any instance variable or method that we might find interesting. If at any point we ended up constructing a pair of a type that does not satisfy the type of the downcast, then an \idx{exception}{Exception} will be thrown. If we don't write code for handling that, then our program will crash. We could make an agreement developer-to-developer that we will never do this, and that there is thus no need to handle any exception. But this is where \idx{human mistakes}{Human mistake} come into play.
  \descitem{Higher cost of use:} In order to \textsl{be able to} throw an exception, the runtime performs a check before downcasting. And that takes a bit of time. Otherwise, an invalid downcast would result in either undefined program behavior, a program \idx{crash}{Crash} or one followed by the other. So, the downcast comes with a runtime penalty.
\end{enumerate}

\section{Solution}

% there is another way though, that is to create a parameterized (or generic) type, definition (named placeholders instead of certain types), define recipe (take class or interface as starting point, insert placeholders for needed types, declare these placeholders as parameters to the type you are defining)
To solve this problem many programming languages have introduced a notion of a \idx{parameterized (or generic) type}{Type!Parameterized}. A type (think class or interface) is parameterized when certain types withing its definition are replaced by named placeholders. The recipe can be written down as:
\begin{enumerate}
  \descitem{Starting Point:} Take a complex type definition as a starting point. As an example we will use the definition of the \classname{IntPair} class from figure \ref{fig:generics:pair:problem}.
  \descitem{Locate References:} Find the references to types that we wish to parameterize. In \classname{IntPair}, we need to find the locations of the types that have to match the two elements that the class wrap. These are the types of the two instance variables and the parameter types for the constructor. It is not the return type of the \methodname{ToString} method. That has to be \typename{string} in order to match the \idx{method prototype}{Method!Prototype} that we are trying to override, and it is independent of the of the type of the wrapped elements.
  \descitem{Insert Placeholders} For each parameterized type, come up with a placeholder name, and replace each found type reference with the matching placeholder name. For placeholder names we usually use single upper-case characters (often \typename{T}). As both elements of our pair needs to be of the same type, we only need a single placeholder name. Lets just use \typename{T}.
  \descitem{Declare Placeholders} Declare that the type is parameterized over the set of placeholder names.
\end{enumerate}

% fig: generic pair
\begin{figure}[tbp]
  \input{figs/generics_pair_solution.tex}
  \caption{Generic pair definition.}
  \label{fig:generics:pair:solution}
\end{figure}

% compiler: then the compiler will automatically generate concrete type variants on demand, if we follow that recipe we end up with FIG, from this the compiler will be able to generate the equivalents of IntPair and PointPair from FIG, note that these do no actually end up in files
If we follow the recipe on the definition of \classname{IntPair} or \classname{PointPair}, we end up with the generic \classname{Pair} definition in figure \ref{fig:generics:pair:solution}. Given such parameterized definitions, the compiler will automatically generate concrete type variants on demand and that demand is driven by actual use. If the code refers to a pair of \typename{int} values, then the equivalent of \classname{IntPair} will be created. If it refers to a pair of dogs, then the equivalent of a \classname{DogPair} will be created. Note that these \textsl{creations} never end up in files.

\section{\csharp}

% syntax: we have already seen what parameterized types look like in csharp, to support this we need to expand our set of allowed syntax
By now, we have already seen what a parameterized class looks like in \csharp. Syntax \ref{syntax:generics:support} and \ref{syntax:generics:classes} formalizes this. Just like classes can be parameterized, so can interfaces. The rules for these can be found in syntax \ref{syntax:generics:interface}. Lets dig into the most interesting details!

\begin{syntaxfloat}
  \input{syntax/generics_support.tex}
  \caption{Support definitions for parameterized types}
  \label{syntax:generics:support}
\end{syntaxfloat}

\begin{syntaxfloat}
  \input{syntax/generics_classes.tex}
  \caption{Class definitions as parameterized types}
  \label{syntax:generics:classes}
\end{syntaxfloat}

\begin{syntaxfloat}
  \input{syntax/generics_interface.tex}
  \caption{Interface definitions as parameterized types}
  \label{syntax:generics:interface}
\end{syntaxfloat}

% declaration of the placeholders

\subsection{Multiple Parameters}

% need for multiple parameters (trivial map implementation)

\subsection{Restrictions on Type}

% problem: knowing that a field exists does know allow us to do much with it
We still haven't actually solved to problem of not having guarantees on the available functionality. In our instance and class variables, we can store references to objects, we can update these references and pass them along to other pieces of code. We need to make sure that our code is valid irrespective of the type others choose as parameters, otherwise the compiler won't be happy. This means that we can't do much else with those fields.

% hack: use of the non-idiomatic construct of a cascading 'is' checks
One non-\idx{idiomatic}{Idiomatic} way of getting around this would be to create a cascade of \idx{is}{is@\texttt{is} keyword} checks. That way, we end up with one \keywordname{if} case per supported type. It tests whether the type of the actual object satisfies some specific type, and -- if so -- hands it over to some code that knows how to deal with it. Otherwise, it hands control over to the next stage in the cascade. These checks would have to be evaluated in sequence, and this would -- on top of the \idx{readability}{Readability} issues stemming from a deep nesting of \keywordname{if} statements -- carry a performance penalty.

% solution: interface solution, awkward/complex to use interfaces (the types that we are not in charge of may need wrapping), restrictions on type (no need to wrap the types of others [e.g., primitive types], need for restrictions on multiple interfaces, constructor availability)

\section{The C Precompiler}

\exercises{generics}{Parameterized Types}

