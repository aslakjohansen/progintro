\chapter{Parameterized Types}

% intro: inheritance as a way to avoid duplicate code, it works by extending some basic definition, but what if the basic definition is the part that we want variations of? 
In chapter \ref{sec:inheritance}, we covered the concept of \idx{inheritance}{Inheritance}. We presented it as a way of avoiding \idx{duplicate code}{Duplicate code} while allowing for \idx{polymorphic}{Polymorphism} access to variants of behavior implementation. It worked by extending some basic definition in order to specialize the type definition. So, a shared starting point with individual extensions. But what if the basic definition is the part that we want variations over? Then we use \idx{parameterized types}{Type!Parameterized} (aka \idx{generics}{Generics}).

\section{Problem}

% what is a pair?
A minimal example of this is a \say{pair}. That is, two of something. The concept could relate to integers, socks, dice or something different altogether. In object-oriented programming, it seems natural to use a class to wrap two elements of the relevant type. Figure \ref{fig:generics:pair:problem} illustrates how such a pair class could be defined for integers and for points.

% fig: code presentation
\begin{figure}[tbp]
  \input{figs/generics_pair_problem.tex}
  \caption{Two similar classes with varying base definition.}
  \label{fig:generics:pair:problem}
\end{figure}

% differences
It doesn't quite feel right though. The concept of the pair is intertwined with the type of the elements. The \methodname{ToString} method and the body of the constructor are exactly the same in the two classes. If we look past the types, then so are the instance variables and constructor parameters. These are all things that are linked to the concept of a pair; not the type of the elements. The only reason for the classes (and thus their constructors) to be named differently is that they can't have the same name.

% problems: scalability
The consequences of this extend beyond mere practicalities. For starters it does not \idx{scale}{Scalability} with respect to element types: We need one definition of a pair for each element type we want to support. So, if I want to have 17 different elements types in pairs, I need 17 different pair classes. That is a lot of code that I have to manually keep up to date as my perception of a pair evolves. This evolution is a reference to how the code changes over time as features are added or bugs corrected. We say that this results in low \idx{maintainability}{Maintainability}.

% problem: no common type
But this still leaves us with a missed opportunity for polymorphism. It would be nice to be able to be able to define code that can can handle any pair. We could accomplish this by placing be pair behavior functionality in an interface that all pair types implement. Then that interface would represent the type that all pairs \idx{satisfy}{Type!Satisfiability}. But we would still have the scalability problem.

% Object
We could define the class as a \typename{Object} pair. That would allow any type to satisfy the instance variables. But we would this would come with two negative consequences, namely:
\begin{enumerate}
  \descitem{Loss of \idx{type specificity}{Type!Specificity}:} We would bypass the \idx{compilers}{Compiler} mechanisms for ensuring \idx{type safety}{Type!Safety} and shift that uncertainty to the \idx{runtime}{Runtime!The}. Without the guarantees of the compiler, we would need to \idx{downcast}{Downcast} our instance variables in order to access any instance variable or method that we might find interesting. If at any point we ended up constructing a pair of a type that does not satisfy the type of the downcast, then an \idx{exception}{Exception} will be thrown. If we don't write code for handling that, then our program will crash. We could make an agreement developer-to-developer that we will never do this, and that there is thus no need to handle any exception. But this is where \idx{human mistakes}{Human mistake} come into play.
  \descitem{Higher cost of use:} In order to \textsl{be able to} throw an exception, the runtime performs a check before downcasting. And that takes a bit of time. Otherwise, an invalid downcast would result in either undefined program behavior, a program \idx{crash}{Crash} or one followed by the other. So, the downcast comes with a runtime penalty.
\end{enumerate}

\section{Solution}

% there is another way though, that is to create a parameterized (or generic) type, definition (named placeholders instead of certain types), define recipe (take class or interface as starting point, insert placeholders for needed types, declare these placeholders as parameters to the type you are defining)
To solve this problem many programming languages have introduced a notion of a \idx{parameterized (or generic) type}{Type!Parameterized}. A type (think class or interface) is parameterized when certain types withing its definition are replaced by named placeholders. The recipe can be written down as:
\begin{enumerate}
  \descitem{Starting Point:} Take a complex type definition as a starting point. As an example we will use the definition of the \classname{IntPair} class from figure \ref{fig:generics:pair:problem}.
  \descitem{Locate References:} Find the references to types that we wish to parameterize. In \classname{IntPair}, we need to find the locations of the types that have to match the two elements that the class wrap. These are the types of the two instance variables and the parameter types for the constructor. It is not the return type of the \methodname{ToString} method. That has to be \typename{string} in order to match the \idx{method prototype}{Method!Prototype} that we are trying to override, and it is independent of the of the type of the wrapped elements.
  \descitem{Insert Placeholders} For each parameterized type, come up with a placeholder name, and replace each found type reference with the matching placeholder name. For placeholder names we usually use single upper-case characters (often \typename{T}). As both elements of our pair needs to be of the same type, we only need a single placeholder name. Lets just use \typename{T}.
  \descitem{Declare Placeholders} Declare that the type is parameterized over the set of placeholder names.
\end{enumerate}

% fig: generic pair
\begin{figure}[tbp]
  \input{figs/generics_pair_solution.tex}
  \caption{Generic pair definition.}
  \label{fig:generics:pair:solution}
\end{figure}

% compiler: then the compiler will automatically generate concrete type variants on demand, if we follow that recipe we end up with FIG, from this the compiler will be able to generate the equivalents of IntPair and PointPair from FIG, note that these do no actually end up in files
If we follow the recipe on the definition of \classname{IntPair} or \classname{PointPair}, we end up with the generic \classname{Pair} definition in figure \ref{fig:generics:pair:solution}. Given such parameterized definitions, the compiler will automatically generate concrete type variants on demand and that demand is driven by actual use. If the code refers to a pair of \typename{int} values, then the equivalent of \classname{IntPair} will be created. If it refers to a pair of dogs, then the equivalent of a \classname{DogPair} will be created. Note that these \textsl{creations} never end up in files.

\section{\csharp}

% syntax: we have already seen what parameterized types look like in csharp, to support this we need to expand our set of allowed syntax

% declaration of the placeholders

\begin{syntaxfloat}
  \input{syntax/generics_interface.tex}
  \caption{Interface definitions as parameterized types}
  \label{syntax:generics:interface}
\end{syntaxfloat}

\begin{syntaxfloat}
  \input{syntax/generics_classes.tex}
  \caption{Class definitions as parameterized types}
  \label{syntax:generics:classes}
\end{syntaxfloat}

\subsection{Multiple Parameters}

% need for multiple parameters (trivial map implementation)

\subsection{Restrictions on Type}

% need for restrictions on type (2d/3d point example so that we can calculate distances)

\section{The C Precompiler}

\exercises{generics}{Parameterized Types}

