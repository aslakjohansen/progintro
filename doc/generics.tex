\chapter{Parameterized Types}

% intro: inheritance as a way to avoid duplicate code, it works by extending some basic definition, but what if the basic definition is the part that we want variations of? 
In chapter \ref{sec:inheritance}, we covered the concept of \idx{inheritance}{Inheritance}. We presented it as a way of avoiding \idx{duplicate code}{Duplicate code} while allowing for \idx{polymorphic}{Polymorphism} access to variants of behavior implementation. It worked by extending some basic definition in order to specialize the type definition. So, a shared starting point with individual extensions. But what if the basic definition is the part that we want variations over? Then we use \idx{parameterized types}{Type!Parameterized} (aka \idx{generics}{Generics}).

\section{Problem}

% what is a pair?
A minimal example of this is a \say{pair}. That is, two of something. The concept could relate to integers, socks, dice or something different altogether. In object-oriented programming, it seems natural to use a class to wrap two elements of the relevant type. Figure \ref{fig:generics:pair:problem} illustrates how such a pair class could be defined for integers and for points.

% fig: code presentation
\begin{figure}[tbp]
  \input{figs/generics_pair_problem.tex}
  \caption{Two similar classes with varying base definition.}
  \label{fig:generics:pair:problem}
\end{figure}

% differences
It doesn't quite feel right though. The concept of the pair is intertwined with the type of the elements. The \methodname{ToString} method and the body of the constructor are exactly the same in the two classes. If we look past the types, then so are the instance variables and constructor parameters. These are all things that are linked to the concept of a pair; not the type of the elements. The only reason for the classes (and thus their constructors) to be named differently is that they can't have the same name.

% problems: scalability
The consequences of this extend beyond mere practicalities. For starters it does not \idx{scale}{Scalability} with respect to element types: We need one definition of a pair for each element type we want to support. So, if I want to have 17 different elements types in pairs, I need 17 different pair classes. That is a lot of code that I have to manually keep up to date as my perception of a pair evolves. That is, when I add features or correct bugs. We say that this results in low \idx{maintainability}{Maintainability}.

% problem: no common type
But this still leaves us with a missed opportunity for polymorphism. It would be nice to be able to be able to define code that can can handle any pair. We could accomplish this by placing be pair behavior functionality in an interface that all pair types implement. Then that interface would represent the type that all pairs \idx{satisfy}{Type!Satisfiability}. But we would still have the scalability problem.

\section{Solution}

\subsection{\csharp}
\subsubsection{Multiple Parameters}
\subsubsection{Restrictions on Type}

\exercises{generics}{Parameterized Types}

