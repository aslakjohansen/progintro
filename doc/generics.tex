\chapter{Parameterized Types}

% intro: inheritance as a way to avoid duplicate code, it works by extending some basic definition, but what if the basic definition is the part that we want variations of? 
In chapter \ref{sec:inheritance}, we covered the concept of \idx{inheritance}{Inheritance}. We presented it as a way of avoiding \idx{duplicate code}{Duplicate code} while allowing for \idx{polymorphic}{Polymorphism} access to variants of behavior implementation. It worked by extending some basic definition in order to specialize the type definition. So, a shared starting point with individual extensions. But what if the basic definition is the part that we want variations over? Then we use \idx{parameterized types}{Type!Parameterized} (aka \idx{generics}{Generics}).

\section{Problem}

% array restrictions: what an array is (1: sequence of allocations of a fixed size, 2: elements of a specific type), on initialization space for a fixed number of elements is allocated on the heap, this works really well for sequences that will have a fixed length throughout the lifetime of our program (e.g., if we have some element per month - the number of months is not likely to change anytime soon, in fact this would break an absolutely incredible amount of software), in other situations this is a problem (e.g., a shopping basket), conclusion(this property (a number of items that is fixed) is really a special case), discussion about the tradeoffs of which limit to set, this is not an attractive solution, we need a way to add or removed elements. 

\subsection{Dynamic Array}

% dynamic array example: what we need is a dynamic array, something that can grow and shrink with the number of elements, we already have the tools for this

\subsection{Pair}

% lets simplify it to pair while recognizing that it is the same underlying problem

\section{Solution}

\subsection{\csharp}
\subsubsection{Multiple Parameters}

\exercises{generics}{Parameterized Types}

