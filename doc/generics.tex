\chapter{Parameterized Types}

% intro: inheritance as a way to avoid duplicate code, it works by extending some basic definition, but what if the basic definition is the part that we want variations of? 
In chapter \ref{sec:inheritance}, we covered the concept of \idx{inheritance}{Inheritance}. We presented it as a way of avoiding \idx{duplicate code}{Duplicate code} while allowing for \idx{polymorphic}{Polymorphism} access to variants of behavior implementation. It worked by extending some basic definition in order to specialize the type definition. So, a shared starting point with individual extensions. But what if the basic definition is the part that we want variations over? Then we use \idx{parameterized types}{Type!Parameterized} (aka \idx{generics}{Generics}).

\section{Problem}

% what is a pair?
A minimal example of this is a \say{pair}. That is, two of something. The concept could relate to integers, socks, dice or something different altogether. In object-oriented programming, it seems natural to use a class to wrap two elements of the relevant type. Figure \ref{fig:generics:pair:problem} illustrates how such a pair class could be defined for integers and for points.

% fig: code presentation
\begin{figure}[tbp]
  \input{figs/generics_pair_problem.tex}
  \caption{Two similar classes with varying base definition.}
  \label{fig:generics:pair:problem}
\end{figure}

% problem: scalability

\section{Solution}

\subsection{\csharp}
\subsubsection{Multiple Parameters}
\subsubsection{Restrictions on Type}

\exercises{generics}{Parameterized Types}

