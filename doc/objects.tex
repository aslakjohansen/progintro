\chapter{Objects}

% working with structs

% example[rectangle]: reference as parameter to functions associated with a struct
\begin{figure}[tbp]
  \inputminted[fontsize=\footnotesize]{csharp}{../src/csharp/rectangle/Rectangle.cs}
  \caption{Implementation of a \classname{Rectangle} using structs.}
  \label{fig:objects:rectangle:lib}
\end{figure}

% the struct is a context: one context for each object

\section{Syntactic Sugar}

% methods rather than functions

% the constructor

\section{The Static Confusion}

% one context shared between all objects

% why call it a class?

\csharpsection{\csharp}
hello

\pythonsection{Python}
hello

\elixirsection{Elixir}
hello

\section{Case: Matrices}

% motivation: matrices are used in many forms of programming, graphics examples
In this section we will briefly cover \idx{matrices}{Matrix}. There are a number of domains where the ability for us to work with matrices is crucial. While they don't provide us with new functionality, they do represent a convenient \idx{abstraction}{Abstraction}, and they certainly help speed up \idx{graphics}{Graphics} and \idx{graph}{Graph} calculations.

% matrix def: rectangular array of numbers, numbers are called entries of the matrix, conventions (m*n matrix A: element names)
So what are they? They are rectangular \idx{arrays}{Array} of numbers. Each of these numbers are called \idx{entries}{Entry!Matrix} of the matrix. The size of a matrix is named after the size along each of the two dimensions: A $2 \times 3$ matrix has a height of $2$ and a width of $3$. If we name the matrix $\mathbf{A}$, then the entries are called:
\begin{equation*}
  \mathbf{A} =
  \left[
    \begin{matrix}
      a_{11} & a_{12} & a_{13} \\
      a_{21} & a_{22} & a_{23}
    \end{matrix}
  \right]
\end{equation*}
So, the dimensions of a matrix are 1-indexed. Madness!

% operations: addition, subtraction
A number of operations are defined on matrices. One can add two matrices of the same size, and one can subtract one matrix from another of the same size:

% figure: addition and subtraction of matrices
\begin{align*}
  \mathbf{A}+\mathbf{B} &=
  \left[
    \begin{matrix}
      a_{11} & a_{12} & \cdots & a_{1n} \\
      a_{21} & a_{22} & \cdots & a_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      a_{m1} & a_{m2} & \cdots & a_{mn} \\
    \end{matrix}
  \right]
  +
  \left[
    \begin{matrix}
      b_{11} & b_{12} & \cdots & b_{1n} \\
      b_{21} & b_{22} & \cdots & b_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      b_{m1} & b_{m2} & \cdots & b_{mn} \\
    \end{matrix}
  \right]
  \\
  &=
  \left[
    \begin{matrix}
      a_{11}+b_{11} & a_{12}+b_{12} & \cdots & a_{1n}+b_{1n} \\
      a_{21}+b_{21} & a_{22}+b_{22} & \cdots & a_{2n}+b_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      a_{m1}+b_{m1} & a_{m2}+b_{m2} & \cdots & a_{mn}+b_{mn} \\
    \end{matrix}
  \right]
  \\
  \mathbf{A}-\mathbf{B} &=
  \left[
    \begin{matrix}
      a_{11} & a_{12} & \cdots & a_{1n} \\
      a_{21} & a_{22} & \cdots & a_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      a_{m1} & a_{m2} & \cdots & a_{mn} \\
    \end{matrix}
  \right]
  -
  \left[
    \begin{matrix}
      b_{11} & b_{12} & \cdots & b_{1n} \\
      b_{21} & b_{22} & \cdots & b_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      b_{m1} & b_{m2} & \cdots & b_{mn} \\
    \end{matrix}
  \right]
  \\
  &=
  \left[
    \begin{matrix}
      a_{11}-b_{11} & a_{12}-b_{12} & \cdots & a_{1n}-b_{1n} \\
      a_{21}-b_{21} & a_{22}-b_{22} & \cdots & a_{2n}-b_{2n} \\
      \vdots & \vdots & \ddots & \vdots \\
      a_{m1}-b_{m1} & a_{m2}-b_{m2} & \cdots & a_{mn}-b_{mn} \\
    \end{matrix}
  \right]
\end{align*}

% operations: (matrix) multiplication
Matrices can take part in \idx{scalar multiplication}{Multiplication!Scalar} and \idx{matrix multiplication}{Multiplication!Matrix}. We will skip scalar multiplication in this book, and focus on matrix multiplication.

% figure: (matrix) multiplication

% special matrices: zeroes, ones, identity
On top of this, there are a number of special matrix configurations that we often use. Sometimes we need a matrix of a particular size where all entries are zero or one. These are known as \idx{constant}{Matrix!Constant} (value) matrices. At other times we need one that is square and has a diagonal of ones starting in the upper left corner. The rest of the entries in this matrix are zeroes. This matrix is called an \idx{identity matrix}{Identity!Matrix}.

\csharpsubsection{\csharp}

% the part that is solved by the object
So, how do we represent a matrix in \csharp? Well, the data fits nicely into a 2d array. For convenience, we would like to place these data inside of an object. This allows us to easily attach behavior in the form of methods and to organize related operations in the \idx{namespace}{Namespace!of class} of the class. Such relevant operations include methods for producing identity matrices, and constant-value matrices. This should not be too much of a stretch.

% the part that is not
The stretch comes when we look into how to best implement the binary matrix operations (i.e., those that take a matrix as at least one of two parameters). Now that we have just learnt of instance methods, that would be an obvious vehicle for implementing this. For the add operation, we would have an instance method defined on a \classname{Matrix} class that takes a \classname{Matrix} as a parameter and return a new \classname{Matrix}. But lets imagine that we want to add four matrices using such implementation:
\begin{minted}{csharp}
Matrix result = matrix1.add(matrix2.add(matrix3.add(matrix4)));
\end{minted}
While it certainly gets the job done, \idx{readability}{Readability} suffer.

% alternative
As an alternative, we can \idx{overload}{Overload!Operators} the ordinary \texttt{+}, \texttt{-} and \texttt{*} operators. To do this, we need to provide \csharp\ with an implementation for each of the relevant function \idx{signatures}{Signature}. The mechanism that \csharp\ has for this is tied to the \idx{dispatch mechanism}{Dispatch mechanism}. A binary operator has two parameters and thus one or two types. We can provide the implementation as a static method on the class of either of these types. This static method is named \say{\texttt{operator +}} for the plus operation, and so on. Using the implementation from figure \ref{fig:objects:matrix:lib}, the example of adding four matrices end up looking like this:
\begin{minted}{csharp}
Matrix result = matrix1 + matrix2 + matrix3 + matrix4;
\end{minted}
For the person who has \textsl{consume} that class (e.g., write code that makes use of it), this interface is a whole lot nicer!

\begin{figure}[tbp]
  \inputminted[fontsize=\footnotesize]{csharp}{../src/csharp/matrix/Matrix.cs}
  \caption{Implementation of \classname{Matrix} class.}
  \label{fig:objects:matrix:lib}
\end{figure}

\exercises{objects}{Objects}

