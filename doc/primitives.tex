\chapter{Primitive Types}

\section{Integers}

\label{sec:int}

% everything is a number, not always obvious, classes of numbers, the simples calls is integers
All values that we may want to work with in a computer are, one way or the other, numbers. This fact may not always be obvious, but it will be quite a while before you encounter such examples. From public school and highschool, we know these classes of numbers:
\begin{itemize}
  \descitem{The natural numbers} ($\mathbb{N}$) These are the non-negative numbers that can be written without a decimal point\footnote{There are two definitions of natural numbers. The other definition is that they are the positive numbers that can be written without a decimal point. That is to say, without zero. As this definition is generally less applicable in computers, we stick to the first definition.}.
  \descitem{The integers} ($\mathbb{Z}$) These are all the natural numbers (according to the first definition) along with the negative versions of the natural numbers (according to the second definition). That definition juggling is to make sure that we don't have a negative zero.
  \descitem{The real numbers} ($\mathbb{R}$) These are all the numbers that can be placed on a line between $-\infty$ and $\infty$. We often refer to these as floating point numbers.
  \descitem{The rational numbers} ($\mathbb{Q}$) These are then numbers that can be written as the fraction $m/n$ where $m \in \mathbb{Z}$ and $m \in \mathbb{N}$.
  \descitem{The irrational numbers} ($\mathbb{P}$) These are numbers that belong to $\mathbb{R}$ but not $\mathbb{Q}$. This is where $\pi$ and $e$ belong.
\end{itemize}
Computers typically works with other classes of numbers. In the following sections, we will explore the most commonly used ones. Common to these is that they are all represented in binary numbers. That is, using the base-2 digits. We are used to working with base-10 where numbers are digits between zero and nine. In base-2, the numbers are made up of digits between zero and one (i.e., \texttt{0} or \texttt{1}). Such a digit is called a \term{bit}, and a sequence of eight bits is referred to as a \term{byte}. The plural forms of the singular bit and byte is bits and bytes. Bits are, by the way, the SI unit of information, in the same way as meter is the SI unit of distance. Accordingly, we measure information in bits.

\subsection{Operations}

% basic operations
All general purpose languages support the four basic arithmetic operators for addition, subtraction, multiplication and division of integers. The tree first of these will guarantee an integral result. For instance, if you add two integers, you will get an integer. The \textsl{size} of this integer may be affected though. But more on that in section \ref{primitives:int:representation}.

% that division thing
That rule, about the result of an operation resuling in an integral value does not hold for the division operation though. Mathematically, the result \textsl{may} be integral, but generally speaking there is no guarantee, and more often than not it is simply not the case. Most programming languages supports two types of division; namely \textsl{integer division} and \textsl{floating-point division}. The result of a floating-point division is a floating-point number as introduced in section \ref{primitives:float}. The result of an integer division is an integer.

% remainder vs modulo
This operation is tightly coupled to both the remainder and the modulo operations. The difference between these is how they handle negative numbers.

% TODO: Figure of remainder vs modulo

\subsection{Representation}
\label{primitives:int:representation}

% typical representation

% signedness

\csharpsubsection{\csharp}

\begin{syntaxsegment}
  Test
\end{syntaxsegment}

\begin{syntax}
  \node[nonterminal] (symbol) at (0,0) {expr};
  \node[empty]       (root)   at (2cm,0) {};
  \node[nonterminal] (ruleIa) at (4cm,0) {expr};
  \node[terminal]    (ruleIb) at (6cm,0) {+};
  \node[nonterminal] (ruleIc) at (8cm,0) {expr};
  \node[nonterminal] (ruleIIa) at (4cm,-2cm) {expr};
  \node[terminal]    (ruleIIb) at (6cm,-2cm) {-};
  \node[nonterminal] (ruleIIc) at (8cm,-2cm) {expr};
  \node[nonterminal] (t) at (4.5cm,-3cm) {h};
  \node[nonterminal] (tt) at (5cm,-3cm) {hq};
  \node[nonterminal] (ttt) at (5.5cm,-3cm) {q};
  
  \draw[path] (root)--(ruleIa)--(ruleIb)--(ruleIc);
  \draw[path] (root)--($(root)!0.5!(ruleIa)$)|-(ruleIIa)--(ruleIIb)--(ruleIIc);
\end{syntax}

% integer types available

% what is the result of int32+int32? what is an overflow?

\elixirsubsection{Elixir}

% alternative representation: pros and cons

\section{Floating Point Numbers}
\label{primitives:float}

\subsection{Operations}
\subsection{Representation}
\csharpsubsection{\csharp}
\elixirsubsection{Elixir}

\section{Truth Values}

% what do they represent

\subsection{Operations on Nontruthy Values}
\subsection{Operations on Truth Values}

\subsection{Representation}

% technically a bit, but typically (mostly unless in array form) a byte or word

\csharpsubsection{\csharp}
\elixirsubsection{Elixir}

\section{Variables}
\csharpsubsection{\csharp}
\elixirsubsection{Elixir}

\section{Parsing}
\subsection{Operator Precedence}
\subsection{Operator Associativity}

