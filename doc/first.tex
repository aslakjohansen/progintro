\chapter{The First Program}
\label{sec:first}

\begin{inspiration}{The Linux Kernel Module Programming Guide\cite{lkmpg20070518}}
  \quoted{When the first caveman programmer chiseled the first program on the walls of the first cave computer, it was a program to paint the string `Hello, world' in Antelope pictures. Roman programming textbooks began with the `Salut, Mundi' program. I don't know what happens to people who break with this tradition, but I think it's safer not to find out.}
\end{inspiration}

\section{Phases}

% ahead-of-time compiled language, compilation phase results in a binary that is transferable (and portable) and can be executed without the precense of the compiler
\csharp\ is an ahead-of-time compiled language. This means that program execution is a step separate from program compilation. Or, to skip the technical terms, there is a compilation phase whereby a special program known as a compiler produces a program binary by processing the program source code. This binary is transferable and (fairly) portable. This means that it can be moved to a different machine and executed without the presence of a compiler. But lets take a step back a take a look of all the involved steps.

\subsection{Project Creation}

First, lets create a directory that can host our project:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp$ mkdir new_project
\end{minted}

Then, we can go to that directory and initalize a new console project:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp$ mkdir new_project
aslak@gaia:/tmp$ cd new_project
aslak@gaia:/tmp/new_project$ dotnet new console
The template "Console App" was created successfully.

Processing post-creation actions...
Restoring /tmp/new_project/new_project.csproj:
  Determining projects to restore...
  Restored /tmp/new_project/new_project.csproj (in 146 ms).
Restore succeeded.
\end{minted}

So, what happened? Lets take a look at what happened in our newly created directory:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ ls
new_project.csproj  obj  Program.cs
\end{minted}

Three files were created, and one of them is a directory:
\begin{itemize}
  \item \filename{new\_project.csproj}: This is a \say{project} file. It holds \idx{metadata}{Metadata} that tells the \commandname{dotnet} command how to build the project. The build process is the process that converts our human-readable source code to a binary that can be executed on a machine. % TODO: add an exercise for determining which version of the framework dotnet should use
  \item \filename{obj}: For now, we don't care much about this directory.
  \item \filename{Program.cs}: This is our program file. It is where we write our code. Later on we will add more files. From the perspective of the \commandname{dotnet} command, the name doesn't matter. However, as your project grows, humans will find is very confusing if certain standards are not met. We will cover these throughout the book.
\end{itemize}

\subsection{Writing}

Open the \filename{Program.cs} in your text editor and make sure the contents is as follows:

\includeCsharpFile{first/hello/Program.cs}

\subsection{Saving}

Save the file. This persists to data that was present in your computers memory under the control of your text editor to disk. That way another program can easily acces it through a valid path to the file.

\subsection{Compilation}

One such program is a compiler, and that happens to be what we need to build the program binary that is needed for execution. That compiler can be called using the \commandname{dotnet} command:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ dotnet build
  Determining projects to restore...
  All projects are up-to-date for restore.
  new_project -> /tmp/new_project/bin/Debug/net8.0/new_project.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:05.36
\end{minted}

If we list the contents of the project directory we will see that a new \filename{bin} directory has been created for storing the binary program:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ ls
bin  new_project.csproj  obj  Program.cs
\end{minted}

\subsection{Execution}

While we say that the compiler has produced an executable binary for us, it is not a binary that our hardware is capable of running. We need a \idx{virtual machine}{Virtual machine} for that. This is essentially a special program that simulates a different architecture. The binary we have contains \idx{Intermediate Language}{Intermediate language (IL)} (IL) bytecode, and we need a \idx{Common Language Runtime}{Common Language Runtime (CLR)} (CLR) virtual machine to execute it. Luckely, once again, the \commandname{dotnet} command gives us access to such:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ dotnet run
Hello, World!
\end{minted}

\subsection{Big Picture}

A typical development cycle looks like figure \ref{fig:first:phases:cycle}: First a project is created, then the developer writes some code that is then compiled and executed. When writing the text editor may provide hints of errors that the developer then takes into account. The \idx{compiler}{Compiler} may give provide feedback in the form of \idx{errors}{Error} or \idx{warnings}{Warning} that need to be addressed. When executing, one might discover \idx{bugs}{Bug} that needs fixing. All of this brings us back to the writing phase.

On top of that, developers usually work on a small portion of the intended functionality. When that functionality is deemed correct -- as there are no indicators of problems in our \textsl{Write}, \textsl{Compile} and \textsl{Execute} phases -- the developer takes on an other portion and starts in the \textsl{Write} phase.

\begin{figure}[tbp]
  \input{figs/first_cycle.tex}
  \caption{Typical developer cycle.}
  \label{fig:first:phases:cycle}
\end{figure}

\pythonsubsection{Python}

In Python, the equivalent program looks like this:

\includePythonFile{first/hello/hello.py}

In order to execute this script, we first need to make the file \idx{executable}{File!Executable}:
\begin{minted}[]{shell-session}
aslak@gaia:/tmp/python_hello$ chmod u+x hello.py
\end{minted}

That first line of the Python source code is called a \idx{shebang}{Shebang} after the first two characters. When executing, this line uses the \filename{/bin/env} program to look up an appropriate interpreter for \filename{python3} and then feed the remaining lines to it. This is known as a \idx{dispatch mechanism}{Dispatch mechanism}. The development cycle is very similar to \csharp\ except that there is neither an initial project creation step or a separate compilation step. Running the program is done like so:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/python_hello$ ./hello.py
Hello, World!
\end{minted}

The Python interpreter has an \idx{interactive mode}{Mode!Interactive} that we can \idx{invoke}{Invoke} directly:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/python_hello$ /bin/env python3
Python 3.13.3 (main, Apr 10 2025, 21:38:51) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello, World!")
Hello, World!
>>> 
\end{minted}

On the first line we invoke the interpreter. Then, it -- exactly as our shell -- presents us with a prompt. This prompt allows us to \idx{issue}{Issue} python commands. The interactive mode is typically used for rapid experimentation.

Another way to write python code is though a \idx{notebook}{Notebook} environment. Such an environment is usually provided through a browser by a system such as \idx{Jupyter}{Jypyter}. In such an environment, code is split up into cells and these cells are laid out in a sequence. Any cell can build on the code that is introduced in previous cells and the code in these cells have easily accessible means for producing visual outputs. The workflow is essentially the same as for \csharp\ except that notebooks are usually saved automatically.

\csubsection{C}

The minimal hello world program in C looks (more or less) like this:

\includeCFile{first/hello/hello.c}

This version immediately looks a lot more complicated! So, why is that? Well, lets try to disect it \ldots

\subsubsection{Explanation}

% first line
Most \idx{general-purpose languages}{Language!General-purpose} (like \csharp, C, Python and Elixir) come with a sizeable \idx{library}{Library} of functionality. While all of this is available to you as a programmer there are downsides to having it all adirectly available all the time. To simplify grossly, it is a situation similar to finding a specific needle in a stack of slighty different needles. The first line tells C -- or rather the C preprocessor -- to include the definitions present in the \filename{stdio.h} file. This pulls in, amongst others, the \funcname{printf} function, that can print stuff to the screen for us.

% main function
Wrapping use of that \funcname{printf} function is the declaration of \funcname{main}. This is the main entry point of the program. That means that this is where the execution of the program starts. It informs the program of how many options have been passed to it (through \varname{argc}) and what those options are (through \varname{argv}). This is \idx{kernels}{Kernel} primary means of informing a program of what inputs it should operate on. The \typename{int} before \funcname{main} indicates that the program evaluates to an integer value. It is convention that a zero indicates success and a non-zero value functions an an \idx{error code}{Error code}. As this program doesn't explicitly return such a number, it will default to zero.

It is important to point out that \csharp\ supports a very similar program structure. After all, this is how the kernel passes options to a program. Any language that supports such options will have something similar. It is typically in a \idx{\funcname{main} function}{Function!Main}. But sometimes it is implicit or has to be actively \idx{imported}{Importing}. That is not likely to mean much to you at this point, and that is okay.

\subsubsection{Workflow}

In order to compile the code to an executable binary we need to invoke a compiler. Lets use the \commandname{clang} compiler and explicitly name the file that should hold the resulting binary:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/c_hello$ clang hello.c -o hello
\end{minted}

One key difference, compared to \csharp, is that C compiles to a \defi{native binary}{Binary!Native}. That is a binary that follows a format that is directly compatible with the processor architecture of your computer. We notice this when executing the code. With \csharp we used \commandname{dotnet} to essentially simulate a virtual machine that was capable of interpreting the intermediate language binary. This manifested as a command that began with \commandname{dotnet}.

The \commandname{dotnet} program that is then invoked is another example of a native binary. So, we can invoke the binary that we have built from our C code in exactly the same way. However, unlike \commandname{dotnet}, our binary is not in the \idx{path}{Path}. That means that we need an \idx{explicit path}{Path!Explicit} to it. That is accomplished by prefacing it with \filename{./}, like so:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/c_hello$ ./hello
Hello, World!
\end{minted}

\elixirsubsection{Elixir}

Elixir code can be executed through an interpreter (like Python), it can be worked on through a notebook system (like Python) and it can be executed on a virtual machine (like \csharp). This virtual machine is called \idx{BEAM}{BEAM}. Unlike that for \csharp, it is a \idx{distributed}{Virtual machine!Distributed} virtual machine. The hello world program looks different depending on whether a separate compilation phase is used or the code is interpreted. For the interpreter, the code looks like this:

\includeElixirFile{first/hello/hello.exs}

% mix creating new project

% interpreter with access to new project

% interpreter hooking into other virtual machine

% livebook

\subsection{Summary}

% ref to fig, what does that mean? Is it better to have more boxes checked? Why and why not?
The covered languages support for \idx{execution models}{Execution model} is summarized in figure \ref{fig:first:phases:summary}. C and \csharp\ only support a single model each, while Elixir supports 5 (or 3 with variations). Does that mean that Elixir is a superior language? No, certainly not. But it does mean that you have more options as to how you execute Elixir code. Sometimes support for specific execution models matter, but often it does not.

\begin{figure}[tbp]
  \input{figs/first_summary.tex}
  \caption{Summary of execution models of various programming languages.}
  \label{fig:first:phases:summary}
\end{figure}

% tradeoffs
It is also important to point out that the design of a programming language is riddled with \idx{tradeoffs}{Tradeoff}, and these are often resolved in very different ways. That results in some set of qualities, of which the supported set of execution models are found. As a developer, it will be your job to decide which combination of qualities are needed to maximize \idx{value}{Value} for a given project, and based on that choose a language.

\input{first_string.tex}

