\chapter{The First Program}
\label{sec:first}

\begin{inspiration}{The Linux Kernel Module Programming Guide\cite{lkmpg20070518}}
  \quoted{When the first caveman programmer chiseled the first program on the walls of the first cave computer, it was a program to paint the string `Hello, world' in Antelope pictures. Roman programming textbooks began with the `Salut, Mundi' program. I don't know what happens to people who break with this tradition, but I think it's safer not to find out.}
\end{inspiration}

\section{Phases}

% ahead-of-time compiled language, compilation phase results in a binary that is transferable (and portable) and can be executed without the precense of the compiler
\csharp\ is an ahead-of-time compiled language. This means that program execution is a step separate from program compilation. Or, to skip the technical terms, there is a compilation phase whereby a special program known as a compiler produces a program binary by processing the program source code. This binary is transferable and (fairly) portable. This means that it can be moved to a different machine and executed without the presence of a compiler. But lets take a step back a take a look of all the involved steps.

\subsection{Project Creation}

First, lets create a directory that can host our project:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp$ mkdir new_project
\end{minted}

Then, we can go to that directory and initalize a new console project:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp$ mkdir new_project
aslak@gaia:/tmp$ cd new_project
aslak@gaia:/tmp/new_project$ dotnet new console
The template "Console App" was created successfully.

Processing post-creation actions...
Restoring /tmp/new_project/new_project.csproj:
  Determining projects to restore...
  Restored /tmp/new_project/new_project.csproj (in 146 ms).
Restore succeeded.
\end{minted}

So, what happened? Lets take a look at what happened in our newly created directory:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ ls
new_project.csproj  obj  Program.cs
\end{minted}

Three files were created, and one of them is a directory:
\begin{itemize}
  \item \filename{new\_project.csproj}: This is a \say{project} file. It holds \idx{metadata}{Metadata} that tells the \commandname{dotnet} command how to build the project. The build process is the process that converts our human-readable source code to a binary that can be executed on a machine. % TODO: add an exercise for determining which version of the framework dotnet should use
  \item \filename{obj}: For now, we don't care much about this directory.
  \item \filename{Program.cs}: This is our program file. It is where we write our code. Later on we will add more files. From the perspective of the \commandname{dotnet} command, the name doesn't matter. However, as your project grows, humans will find is very confusing if certain standards are not met. We will cover these throughout the book.
\end{itemize}

\subsection{Writing}

Open the \filename{Program.cs} in your text editor and make sure the contents is as follows:

\includeCsharpFile{first/hello/Program.cs}

\subsection{Saving}

Save the file. This persists to data that was present in your computers memory under the control of your text editor to disk. That way another program can easily acces it through a valid path to the file.

\subsection{Compilation}

One such program is a compiler, and that happens to be what we need to build the program binary that is needed for execution. That compiler can be called using the \commandname{dotnet} command:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ dotnet build
  Determining projects to restore...
  All projects are up-to-date for restore.
  new_project -> /tmp/new_project/bin/Debug/net8.0/new_project.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:05.36
\end{minted}

If we list the contents of the project directory we will see that a new \filename{bin} directory has been created for storing the binary program:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ ls
bin  new_project.csproj  obj  Program.cs
\end{minted}

\subsection{Execution}

While we say that the compiler has produced an executable binary for us, it is not a binary that our hardware is capable of running. We need a \idx{virtual machine}{Virtual machine} for that. This is essentially a special program that simulates a different architecture. The binary we have contains \idx{Intermediate Language}{Intermediate language (IL)} (IL) bytecode, and we need a \idx{Common Language Runtime}{Common Language Runtime (CLR)} (CLR) virtual machine to execute it. Luckely, once again, the \commandname{dotnet} command gives us access to such:

\begin{minted}[]{shell-session}
aslak@gaia:/tmp/new_project$ dotnet run
Hello, World!
\end{minted}

\subsection{Big Picture}

A typical development cycle looks like figure \ref{fig:first:phases:cycle}: First a project is created, then the developer writes some code that is then compiled and executed. When writing the text editor may provide hints of errors that the developer then takes into account. The \idx{compiler}{Compiler} may give provide feedback in the form of \idx{errors}{Error} or \idx{warnings}{Warning} that need to be addressed. When executing, one might discover \idx{bugs}{Bug} that needs fixing. All of this brings us back to the writing phase.

On top of that, developers usually work on a small portion of the intended functionality. When that functionality is deemed correct -- as there are no indicators of problems in our \textsl{Write}, \textsl{Compile} and \textsl{Execute} phases -- the developer takes on an other portion and starts in the \textsl{Write} phase.

\begin{figure}[tbp]
  \input{figs/first_cycle.tex}
  \caption{Typical developer cycle.}
  \label{fig:first:phases:cycle}
\end{figure}

\pythonsubsection{Python}

\includePythonFile{first/hello/hello.py}

\csubsection{C}

\includeCFile{first/hello/hello.c}

\elixirsubsection{Elixir}

\includeElixirFile{first/hello/hello.exs}

\input{first_string.tex}

