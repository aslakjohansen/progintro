\chapter{Basic Datastructures}

% the problem of working with individual values (keeping track of things)

\section{Types}

\subsection{Complex Types}

\subsection{Reference Types}

\section{Structured Data}

\subsection{Colors}

% light as a spectrum
\defix{Light} is made up of photons, and each \idx{photon}{Photon} has a wavelength. The \defi{wavelength}{Wavelength} of the photons determines which color our eyes will observe. A wavelength of 380nm is \idx{violet}{Violet} and one of 740nm is \idx{red}{Red}. In between these you have all the colors of the \idx{rainbow}{Rainbow}, in the order of the rainbow. Coincidence? Just outside of the \idx{visible spectrum}{Spectrum!Visible}, you will find \idx{infra-red}{Infra-red} and \idx{ultra-violet}{Untra-violet}. Our eyes are, however, constantly bombarded by photons, so in reality we always observe a distribution across this spectrum. Our \idx{eyes}{Eye}, though only has three (or four) tunings of receptors. These, roughly corresponds to red, green and blue. So, your eyes (and \idx{brains}{Brain}) need to do a lot of interpretation.

% computer representation
In a computer, colors are typically \idx{represented}{Representation!Color} using three values; one for red intensity, one for green intensity, and one for blue intensity. That somehow matches the model of our eyes \ldots We say that these are the \textsl{components} of the color. There is a number of ways to express such an \idx{intensity}{Intensity}. It seem natural to use a number between 0 and 100, or perhaps a number between 0.0 and 1.0. However, due to the way processors work on integers, these boundaries are not particularly special. Typically, a byte is use to represent each component of the color. That means that we have the ability to express $2^8=256$ different intensities of each component, or a total of $256^3=16777216$ different colors. The value zero is used to represent complete \idx{darkness}{Darkness}. Full intensity is then the value 255.

% figure: color cube
\begin{figure}[tbp]
  \input{figs/rgb_color_cube.tex}
  \caption{RGB color cube.}
  \label{fig:primdata:struct:color}
\end{figure}

% color spaces
This constitutes a \defi{color space}{Color!Space} whereby all colors fit within a \idx{color cube}{Color!Cube} spanned by the red, green and blue color vectors. Hence, it is named the \idxx{RGB} color space. Figure \ref{fig:primdata:struct:color} depicts this space. It is a direct fit for how \idx{GPUs}{GPU} represent \idx{images}{Image}. Other color spaces exist though, and there are good reasons for their existence. Other popular color spaces include \idxx{HSV} (which is shaped like a cylinder) and \idxx{XYZ} (which is shaped like an tongue). Formulas exists for \idx{converting}{Color!Space!Converting} between these. Each of these color spaces represents practical simplifications of what light really is.

\csharpsubsection{\csharp}

% value type through struct, reference type through class

\begin{syntaxfloat}
  \input{syntax/data_struct.tex}
  \caption{Structured data}
  \label{syntax:data:struct}
\end{syntaxfloat}

\section{Sequences in Data}

\subsection{Arrays}

\begin{figure}[tbp]
  \input{figs/data_array_alloc.tex}
  \caption{The positioning of an array in memory.}
  \label{fig:data:array:alloc}
\end{figure}

\subsubsection{Indexing}

% calculation, this is why most languages agree that arrays start at zero

\begin{figure}[tbp]
  \input{figs/data_array_index.tex}
  \caption{The indexing of an array.}
  \label{fig:data:array:index}
\end{figure}

\subsubsection{Arrays of Arrays}


\begin{figure}[tbp]
  \begin{subfigure}[b]{0.45\textwidth}
    \input{figs/data_array_nest_square.tex}
    \caption{Nesting into square.}
    \label{fig:data:array:nest:square}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \input{figs/data_array_nest_triangle.tex}
    \caption{Nesting into triangle.}
    \label{fig:data:array:nest:triangle}
  \end{subfigure}
  \caption{Nesting arrays in arrays.}
  \label{fig:data:array:nest}
\end{figure}

\subsubsection{Multidimensional Arrays}

\begin{alignat}{1}
  \left(
    \begin{array}{c}
      x \\
      y
    \end{array}
  \right)
  &= 
  \left(
    \begin{array}{c}
      \textcolor{teal}{i} ~\mathrm{mod}~ width \\
      \lfloor \textcolor{teal}{i} / width \rfloor
    \end{array}
  \right)
  \\
  i &= \textcolor{teal}{y} \cdot width + \textcolor{teal}{x}
\end{alignat}

\csharpsubsubsection{\csharp}

\begin{syntaxfloat}
  \input{syntax/data_array.tex}
  \caption{Arrays}
  \label{syntax:data:array}
\end{syntaxfloat}

% expr: explain loop

% arr-decl: explain recursion

% arr-decl: explain the burden on the type checker

\begin{syntaxfloat}
  \input{syntax/data_marray.tex}
  \caption{Multidimensional arrays}
  \label{syntax:data:marray}
\end{syntaxfloat}

\subsection{Linked Lists}

% head and tail

\subsection{Doubly Linked Lists}

\subsection{Looping Sequences}

\subsection{Nesting}

\subsection{Points}

\section{Enumerations}

\subsection{State Machines}

\subsection{String Parsing Example}

\section{Case: Dynamic Arrays} % TODO: should this go into the function chapter?

% problem: arrays have a static size

% observation: a variable only references an array

% solution: Wrap the array in a struct

\csharpsubsection{\csharp}

\begin{syntaxfloat}
  \input{syntax/data_enum.tex}
  \caption{Enums}
  \label{syntax:data:enum}
\end{syntaxfloat}

